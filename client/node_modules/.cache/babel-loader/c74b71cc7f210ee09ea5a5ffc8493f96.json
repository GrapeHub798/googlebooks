{"ast":null,"code":"import { ADD_FAVORITE, DELETE_FAVORITE, UPDATE_BOOKS, UPDATE_PAGE } from '../constants/action-types';\nimport BookCollection from \"../../model/bookcollection.model\";\nconst initialState = {\n  collection: [],\n  favorites: []\n};\n\nconst rootReducer = (state = initialState, action) => {\n  if (action.type === UPDATE_BOOKS) {\n    let collectionState = initialState.collection;\n    const collectionToUpdate = action.payload.collectionName;\n\n    if (collectionToUpdate in collectionState) {\n      collectionState[collectionToUpdate].updateCollection(action.payload);\n    } else {\n      const newCollection = new BookCollection();\n      collectionState[collectionToUpdate] = newCollection.updateCollection(action.payload);\n    }\n    /*\n    // get the correct collection\n    \tif (!collectionToUpdate) {\n    \treturn {...initialState};\n    }\n    \tconst newCollection = new BookCollection();\n    state.collection[collectionToUpdate] = newCollection.updateCollection(action.payload);\n     */\n\n\n    return initialState;\n  }\n\n  if (action.type === UPDATE_PAGE) {\n    const collectionToUpdate = action.payload.collectionName;\n\n    if (!collectionToUpdate) {\n      return { ...initialState\n      };\n    }\n\n    const currentCollection = state.collection[collectionToUpdate];\n\n    if (!currentCollection) {\n      return { ...initialState\n      };\n    }\n\n    return Object.assign({}, currentCollection, {\n      currentIndex: action.payload.currentIndex,\n      currentPage: action.payload.currentPage\n    });\n  }\n\n  if (action.type === ADD_FAVORITE) {\n    return Object.assign({}, state, {\n      favorites: state.favorites.concat(action.payload)\n    });\n  }\n\n  if (action.type === DELETE_FAVORITE) {\n    return Object.assign({}, state, {\n      favorites: state.favorites.concat(action.payload)\n    });\n  }\n\n  return state;\n};\n\nexport default rootReducer;","map":{"version":3,"sources":["D:/Code/googlebooks/client/src/redux/reducers/index.jsx"],"names":["ADD_FAVORITE","DELETE_FAVORITE","UPDATE_BOOKS","UPDATE_PAGE","BookCollection","initialState","collection","favorites","rootReducer","state","action","type","collectionState","collectionToUpdate","payload","collectionName","updateCollection","newCollection","currentCollection","Object","assign","currentIndex","currentPage","concat"],"mappings":"AAAA,SAAQA,YAAR,EAAsBC,eAAtB,EAAuCC,YAAvC,EAAqDC,WAArD,QAAuE,2BAAvE;AACA,OAAOC,cAAP,MAA2B,kCAA3B;AAEA,MAAMC,YAAY,GAAG;AACpBC,EAAAA,UAAU,EAAE,EADQ;AAEpBC,EAAAA,SAAS,EAAE;AAFS,CAArB;;AAKA,MAAMC,WAAW,GAAG,CAACC,KAAK,GAAGJ,YAAT,EAAuBK,MAAvB,KAAkC;AACrD,MAAIA,MAAM,CAACC,IAAP,KAAgBT,YAApB,EAAkC;AACjC,QAAIU,eAAe,GAAGP,YAAY,CAACC,UAAnC;AACA,UAAMO,kBAAkB,GAAGH,MAAM,CAACI,OAAP,CAAeC,cAA1C;;AACA,QAAIF,kBAAkB,IAAID,eAA1B,EAA0C;AACzCA,MAAAA,eAAe,CAACC,kBAAD,CAAf,CAAoCG,gBAApC,CAAqDN,MAAM,CAACI,OAA5D;AACA,KAFD,MAEK;AACJ,YAAMG,aAAa,GAAG,IAAIb,cAAJ,EAAtB;AACAQ,MAAAA,eAAe,CAACC,kBAAD,CAAf,GAAsCI,aAAa,CAACD,gBAAd,CAA+BN,MAAM,CAACI,OAAtC,CAAtC;AACA;AAED;;;;;;;;;;AAWA,WAAOT,YAAP;AACA;;AAED,MAAIK,MAAM,CAACC,IAAP,KAAgBR,WAApB,EAAiC;AAChC,UAAMU,kBAAkB,GAAGH,MAAM,CAACI,OAAP,CAAeC,cAA1C;;AACA,QAAI,CAACF,kBAAL,EAAyB;AACxB,aAAO,EAAC,GAAGR;AAAJ,OAAP;AACA;;AAED,UAAMa,iBAAiB,GAAGT,KAAK,CAACH,UAAN,CAAiBO,kBAAjB,CAA1B;;AACA,QAAI,CAACK,iBAAL,EAAwB;AACvB,aAAO,EAAC,GAAGb;AAAJ,OAAP;AACA;;AACD,WAAOc,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,iBAAlB,EAAqC;AAC3CG,MAAAA,YAAY,EAAEX,MAAM,CAACI,OAAP,CAAeO,YADc;AAE3CC,MAAAA,WAAW,EAAEZ,MAAM,CAACI,OAAP,CAAeQ;AAFe,KAArC,CAAP;AAIA;;AAED,MAAIZ,MAAM,CAACC,IAAP,KAAgBX,YAApB,EAAkC;AACjC,WAAOmB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBX,KAAlB,EAAyB;AAC/BF,MAAAA,SAAS,EAAEE,KAAK,CAACF,SAAN,CAAgBgB,MAAhB,CAAuBb,MAAM,CAACI,OAA9B;AADoB,KAAzB,CAAP;AAGA;;AAED,MAAIJ,MAAM,CAACC,IAAP,KAAgBV,eAApB,EAAqC;AACpC,WAAOkB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBX,KAAlB,EAAyB;AAC/BF,MAAAA,SAAS,EAAEE,KAAK,CAACF,SAAN,CAAgBgB,MAAhB,CAAuBb,MAAM,CAACI,OAA9B;AADoB,KAAzB,CAAP;AAGA;;AACD,SAAOL,KAAP;AACA,CArDD;;AAuDA,eAAeD,WAAf","sourcesContent":["import {ADD_FAVORITE, DELETE_FAVORITE, UPDATE_BOOKS, UPDATE_PAGE} from '../constants/action-types';\nimport BookCollection from \"../../model/bookcollection.model\";\n\nconst initialState = {\n\tcollection: [],\n\tfavorites: [],\n};\n\nconst rootReducer = (state = initialState, action) => {\n\tif (action.type === UPDATE_BOOKS) {\n\t\tlet collectionState = initialState.collection;\n\t\tconst collectionToUpdate = action.payload.collectionName;\n\t\tif (collectionToUpdate in collectionState){\n\t\t\tcollectionState[collectionToUpdate].updateCollection(action.payload);\n\t\t}else{\n\t\t\tconst newCollection = new BookCollection();\n\t\t\tcollectionState[collectionToUpdate] = newCollection.updateCollection(action.payload);\n\t\t}\n\n\t\t/*\n\t\t// get the correct collection\n\n\t\tif (!collectionToUpdate) {\n\t\t\treturn {...initialState};\n\t\t}\n\n\t\tconst newCollection = new BookCollection();\n\t\tstate.collection[collectionToUpdate] = newCollection.updateCollection(action.payload);\n\t\t */\n\n\t\treturn initialState\n\t}\n\n\tif (action.type === UPDATE_PAGE) {\n\t\tconst collectionToUpdate = action.payload.collectionName;\n\t\tif (!collectionToUpdate) {\n\t\t\treturn {...initialState};\n\t\t}\n\n\t\tconst currentCollection = state.collection[collectionToUpdate];\n\t\tif (!currentCollection) {\n\t\t\treturn {...initialState};\n\t\t}\n\t\treturn Object.assign({}, currentCollection, {\n\t\t\tcurrentIndex: action.payload.currentIndex,\n\t\t\tcurrentPage: action.payload.currentPage,\n\t\t});\n\t}\n\n\tif (action.type === ADD_FAVORITE) {\n\t\treturn Object.assign({}, state, {\n\t\t\tfavorites: state.favorites.concat(action.payload),\n\t\t});\n\t}\n\n\tif (action.type === DELETE_FAVORITE) {\n\t\treturn Object.assign({}, state, {\n\t\t\tfavorites: state.favorites.concat(action.payload),\n\t\t});\n\t}\n\treturn state;\n};\n\nexport default rootReducer;\n"]},"metadata":{},"sourceType":"module"}